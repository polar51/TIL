# Today I Learned

## 2025.12.17

### 코딩 테스트

#### 1레벨 크기가 작은 부분 문자열

- 쉽게 풀었는데 컴프리헨션을 사용하려다가 실패함 아직은 컴프리헨션에 대한 이해도가 낮다

#### 1레벨 덧칠하기

- 일단 어거지로 만든 코드는 시간 초과로 탈락
- n부터 돌리고 보자는 식보다는 그리디 탐색으로 section 부분을 생각해야함
- 굳이 배열을 삭제하면서 하기보다는 그냥 지정된 만큼만 탐색하고 그 이하는 버리고 넘기는 방식이 좋다.
- 한번 칠할때 이어지는 최대점을 구하고 section의 요소중 최대점 이하의 요소는 비교하지않고 넘긴다.

### 객체 리터럴과 class 함수

```js
// 설정 객체 (외부에 선언하여 관리)
const DEVICE_CONFIG = {
  colors: {
    ok: "bg-green-500", // CSS 클래스 예시
    warning: "bg-yellow-500",
    error: "bg-red-500",
    offline: "bg-gray-400",
  },
  text: {
    ok: "정상 작동",
    warning: "점검 필요",
    error: "에러 발생",
    offline: "연결 끊김",
  },
};

class Device {
  constructor(id) {
    this.id = id;
    this.element = document.getElementById(`device-${id}`);
    this.statusText = this.element.querySelector(".status");
  }

  update(status) {
    // 1. 기존 클래스 초기화 (기존 색상 제거)
    // Object.values를 쓰면 설정된 모든 색상 클래스를 가져올 수 있습니다.
    this.element.classList.remove(...Object.values(DEVICE_CONFIG.colors));

    // 2. 매핑 객체(Lookup)를 사용해 새 클래스 적용
    const newClass = DEVICE_CONFIG.colors[status] || DEVICE_CONFIG.colors.offline;
    this.element.classList.add(newClass);

    // 3. 텍스트도 매핑 객체로 변경
    this.statusText.innerText = DEVICE_CONFIG.text[status] || status;
  }
}
```

- 가장 우리 회사의 코드에 잘 어울릴만한 코드다. 객체 리터럴에 함수를 포함하는 방식은 1개의 커스텀 함수가 생기는 것이고 class 방식의 컴포넌트 함수는 재사용 가능성을 높히고 유지 보수 성도 높힌다.
- 클래스 모듈로 빼고 constructor와 update data를 비교해서 렌더링 낭비를 줄이자
